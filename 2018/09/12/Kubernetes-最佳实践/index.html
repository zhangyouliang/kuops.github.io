<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Kubernetes 的最佳实践"><meta name="keywords" content=""><meta name="author" content="kuops,undefined"><meta name="copyright" content="kuops"><title>Kubernetes 的最佳实践 | Kuops Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.4"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: undefined
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes的最佳实践"><span class="toc-number">1.</span> <span class="toc-text">Kubernetes的最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-构建容器"><span class="toc-number">2.</span> <span class="toc-text">1. 构建容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#不要轻易相信任何镜像"><span class="toc-number">2.1.</span> <span class="toc-text">不要轻易相信任何镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#保持基础镜像最小化"><span class="toc-number">2.2.</span> <span class="toc-text">保持基础镜像最小化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编译和运行镜像分开"><span class="toc-number">2.3.</span> <span class="toc-text">编译和运行镜像分开</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-容器内部"><span class="toc-number">3.</span> <span class="toc-text">2. 容器内部</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在容器内使用非root用户"><span class="toc-number">3.1.</span> <span class="toc-text">在容器内使用非root用户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件系统只读"><span class="toc-number">3.2.</span> <span class="toc-text">文件系统只读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#每个容器一个进程"><span class="toc-number">3.3.</span> <span class="toc-text">每个容器一个进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应当让容器中的进程需要错误返回错误码，并退出，而不是继续运行"><span class="toc-number">3.4.</span> <span class="toc-text">应当让容器中的进程需要错误返回错误码，并退出，而不是继续运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将所有的输出打印到到-stdout-和-stderr"><span class="toc-number">3.5.</span> <span class="toc-text">将所有的输出打印到到 stdout 和 stderr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Deployment"><span class="toc-number">4.</span> <span class="toc-text">3. Deployment</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-record-选项可以更轻松地回滚"><span class="toc-number">4.1.</span> <span class="toc-text">使用 --record 选项可以更轻松地回滚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用大量描述性标签"><span class="toc-number">4.2.</span> <span class="toc-text">使用大量描述性标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-sidecar-模式来进行代理，监视"><span class="toc-number">4.3.</span> <span class="toc-text">使用 sidecar 模式来进行代理，监视</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不要使用-sidecars-进行启动引导"><span class="toc-number">4.4.</span> <span class="toc-text">不要使用 sidecars 进行启动引导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不要使用：latest-或没有标签"><span class="toc-number">4.5.</span> <span class="toc-text">不要使用：latest 或没有标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Readiness-and-Liveness-是你的朋友"><span class="toc-number">4.6.</span> <span class="toc-text">Readiness and Liveness 是你的朋友</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Service"><span class="toc-number">5.</span> <span class="toc-text">4. Service</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#不要使用-LoadBalancer-类型"><span class="toc-number">5.1.</span> <span class="toc-text">不要使用 LoadBalancer 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nodeport-类型足够好"><span class="toc-number">5.2.</span> <span class="toc-text">Nodeport 类型足够好</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将外部服务映射到内部服务"><span class="toc-number">5.3.</span> <span class="toc-text">将外部服务映射到内部服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-应用程序架构"><span class="toc-number">6.</span> <span class="toc-text">5. 应用程序架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-helm-charts"><span class="toc-number">6.1.</span> <span class="toc-text">使用 helm charts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#所有下游依赖项都不可靠"><span class="toc-number">6.2.</span> <span class="toc-text">所有下游依赖项都不可靠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#确保您的微服务不是太微"><span class="toc-number">6.3.</span> <span class="toc-text">确保您的微服务不是太微</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用命名空间来拆分群集"><span class="toc-number">6.4.</span> <span class="toc-text">使用命名空间来拆分群集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于角色的访问控制"><span class="toc-number">6.5.</span> <span class="toc-text">基于角色的访问控制</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">kuops</div><div class="author-info__description text-center">巧者劳而智者忧，无能者无所求</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">36</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">5</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1529517901642&amp;di=5f7db410ab487b78dd0afc85bc246702&amp;imgtype=0&amp;src=http%3A%2F%2Fimg5.duitang.com%2Fuploads%2Fitem%2F201610%2F21%2F20161021234613_KvFXP.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Kuops Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Kubernetes 的最佳实践</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-12</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/kubernetes/">kubernetes</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><h2 id="Kubernetes的最佳实践"><a href="#Kubernetes的最佳实践" class="headerlink" title="Kubernetes的最佳实践"></a>Kubernetes的最佳实践</h2><p>此演讲稿中的最佳实践源于 Sandeep 及其团队关于您可以在 Kubernetes 中执行相同任务的许多不同方式的讨论。他们编制了一份这些任务的清单，并从中衍生出一套最佳实践。</p>
<p>最佳实践分为：</p>
<ol>
<li>建筑容器</li>
<li>容器内部</li>
<li>部署</li>
<li>服务</li>
<li>应用架构</li>
</ol>
<h2 id="1-构建容器"><a href="#1-构建容器" class="headerlink" title="1. 构建容器"></a>1. 构建容器</h2><h3 id="不要轻易相信任何镜像"><a href="#不要轻易相信任何镜像" class="headerlink" title="不要轻易相信任何镜像"></a>不要轻易相信任何镜像</h3><p>人们将从 DockerHub 中获取某人创建的基础图像，因为乍一看它有他们需要的包，随后将其选择的容器推送到生产环境中。</p>
<p>这有很多错误：您可能使用了具有漏洞的错误代码版本，其中存在错误，或者更糟糕的是它可能会故意捆绑恶意软件，您只是不知道。</p>
<h3 id="保持基础镜像最小化"><a href="#保持基础镜像最小化" class="headerlink" title="保持基础镜像最小化"></a>保持基础镜像最小化</h3><p>基于最精简的基础镜像，从顶部开始构建软件包，这样你就知道镜像里面全部内容。</p>
<p>较小的基础映像也可以减少开销。您的应用程序可能只有大约 5 MB，但如果您盲目地使用现成的图像，例如 Node.js，它包含一个额外的 600MB 库，而您不需要。</p>
<p>较小图像的其他优点：</p>
<ul>
<li>更快的构建</li>
<li>存储量减少</li>
<li>镜像拉取更快</li>
<li>攻击面可能较小</li>
</ul>
<h3 id="编译和运行镜像分开"><a href="#编译和运行镜像分开" class="headerlink" title="编译和运行镜像分开"></a>编译和运行镜像分开</h3><p>此模式对于编译对 Go 和 C++ 或 Typescript for Node.js 的静态语言更有用，分为构建容器和运行时容器。</p>
<p>在这种模式中，您将拥有一个包含编译器，依赖项和单元测试的构建容器。然后通过运行构建容器构建出需要的构建产物。它将静态文件，包，代码等组合在一起，最后通过运行时容器运行，该容容器也可以包含一些监视或调试工具。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3</span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line">RUN go get -d -v golang.org/x/net/html  </span><br><span class="line">COPY app.go .</span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br><span class="line"></span><br><span class="line">FROM alpine:latest  </span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY --from=0 /go/src/github.com/alexellis/href-counter/app .</span><br><span class="line">CMD [&quot;./app&quot;]</span><br></pre></td></tr></table></figure>
<p>第二个 <code>FROM</code> 指令以 <code>alpine:latest</code> 图像为基础开始一个新的构建阶段。该 <code>COPY --from=0</code> 行仅将前一阶段的构建工件复制到此新阶段。Go SDK 和任何中间工件都被遗忘，而不保存在最终图像中。</p>
<h2 id="2-容器内部"><a href="#2-容器内部" class="headerlink" title="2. 容器内部"></a>2. 容器内部</h2><h3 id="在容器内使用非root用户"><a href="#在容器内使用非root用户" class="headerlink" title="在容器内使用非root用户"></a>在容器内使用非root用户</h3><p>如果在容器内部使用 root 用户的话，需要将用户更改为非 root 用户。</p>
<p>原因是，如果有人攻击您的容器并且您没有从 root 更改为普通用户，那么简单的容器逃逸可以让他们以 root 用户访问您的宿主机。当您将用户更改为非 root 用户时，黑客需要额外的尝试才能获得 root 访问权限</p>
<p>在 Kubernetes 中，您可以通过设置安全性上下文 <code>runAsNonRoot: true</code> 来强制执行此操作，以下配置实例对 pod 生效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1  </span><br><span class="line">kind: Pod  </span><br><span class="line">metadata:  </span><br><span class="line">  name: hello-world  </span><br><span class="line">spec:  </span><br><span class="line">  containers:  </span><br><span class="line">  # specification of the pod’s containers  </span><br><span class="line">  # ...  </span><br><span class="line">  securityContext:  </span><br><span class="line">    readOnlyRootFilesystem: true  </span><br><span class="line">    runAsNonRoot: true</span><br></pre></td></tr></table></figure>
<h3 id="文件系统只读"><a href="#文件系统只读" class="headerlink" title="文件系统只读"></a>文件系统只读</h3><p>通过设置 <code>readOnlyRootFilesystem: true</code> 生效</p>
<h3 id="每个容器一个进程"><a href="#每个容器一个进程" class="headerlink" title="每个容器一个进程"></a>每个容器一个进程</h3><p>您可以在容器中运行多个进程，但建议只运行一个进程。这是由 orchestrator 的工作方式决定的。Kubernetes 根据单个进程是否健康来管理容器。如果你在一个容器里面有20个进程，它如何知道容器是否健康呢？</p>
<h3 id="应当让容器中的进程需要错误返回错误码，并退出，而不是继续运行"><a href="#应当让容器中的进程需要错误返回错误码，并退出，而不是继续运行" class="headerlink" title="应当让容器中的进程需要错误返回错误码，并退出，而不是继续运行"></a>应当让容器中的进程需要错误返回错误码，并退出，而不是继续运行</h3><p>Kubernetes 为您重新启动失败的容器，因此您应该使用错误代码使程序彻底崩溃，以便他们可以在没有您干预的情况下成功重新启动，当前你也可以使用 pod 的 restartPolicy 根据探针的结果进行重启。</p>
<h3 id="将所有的输出打印到到-stdout-和-stderr"><a href="#将所有的输出打印到到-stdout-和-stderr" class="headerlink" title="将所有的输出打印到到 stdout 和 stderr"></a>将所有的输出打印到到 stdout 和 stderr</h3><p>默认情况下，Kubernetes 会侦听这些管道并将输出发送到您的日志记录服务。</p>
<h2 id="3-Deployment"><a href="#3-Deployment" class="headerlink" title="3. Deployment"></a>3. Deployment</h2><h3 id="使用-record-选项可以更轻松地回滚"><a href="#使用-record-选项可以更轻松地回滚" class="headerlink" title="使用 --record 选项可以更轻松地回滚"></a>使用 <code>--record</code> 选项可以更轻松地回滚</h3><p>应用yaml时，请使用–record标志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f deployment.yaml --record</span><br></pre></td></tr></table></figure>
<p>使用此选项，每次有更新时，它都会保存到这些部署的历史记录中，并使您能够回滚更改。</p>
<p><img src="https://images.contentstack.io/v3/assets/blt300387d93dabf50e/blt42e000d51356716d/5b8462f6c44e2f610ba7c7bd/download" alt=""></p>
<h3 id="使用大量描述性标签"><a href="#使用大量描述性标签" class="headerlink" title="使用大量描述性标签"></a>使用大量描述性标签</h3><p>由于标签是任意键值对，因此它们非常强大。例如，考虑下面的图表，名为’Nifty’的应用程序分布在四个容器中。使用标签，您可以通过选择后端</p>
<p><img src="https://images.contentstack.io/v3/assets/blt300387d93dabf50e/blteae056bbbd42d417/5b8463070cdef43e0b861e3b/download" alt=""></p>
<h3 id="使用-sidecar-模式来进行代理，监视"><a href="#使用-sidecar-模式来进行代理，监视" class="headerlink" title="使用 sidecar 模式来进行代理，监视"></a>使用 sidecar 模式来进行代理，监视</h3><p>有时您需要一组进程来相互通信。但是你不希望所有这些都在一个容器中运行，（参见上面“每个容器一个进程”），而是在Pod中运行相关进程。</p>
<p>同样，当您运行的进程需要依赖另一个程序时，例如，您的进程所依赖的数据库，而您不虚要把凭据存入到每个容器中，相反可以使用 sidecar 模式来启动代理容器负责管理数据库连接。</p>
<h3 id="不要使用-sidecars-进行启动引导"><a href="#不要使用-sidecars-进行启动引导" class="headerlink" title="不要使用 sidecars 进行启动引导"></a>不要使用 sidecars 进行启动引导</h3><p>虽然 sidecars 非常适合处理集群内外的请求，但 Sandeep 不建议使用它们进行自举。在过去，bootstrapp 是唯一的选择，但现在 Kubernetes 有 <code>init containers</code>。</p>
<p>当容器里面的一个进程依赖于其它的一个微服务时，你可以使用 init 容器一直等待两个进程同时启动再启动容器。这可以防止在进程和微服务不同步时发生大量错误。</p>
<p>基本上规则是：对于始终发生的事件使用 sidecars ，对于一次性事件使用init容器。</p>
<h3 id="不要使用：latest-或没有标签"><a href="#不要使用：latest-或没有标签" class="headerlink" title="不要使用：latest 或没有标签"></a>不要使用：latest 或没有标签</h3><p>这个很明显，大多数人今天也这样做了。如果您没有为容器添加标记，它将始终尝试从存储库中提取最新的标记，这可能包含也可能不包含您认为具有的更改。</p>
<h3 id="Readiness-and-Liveness-是你的朋友"><a href="#Readiness-and-Liveness-是你的朋友" class="headerlink" title="Readiness and Liveness 是你的朋友"></a>Readiness and Liveness 是你的朋友</h3><p>可以使用探测器，以便 Kubernetes 知道节点是否健康以及是否应该向其发送流量。默认情况下，Kubernetes 会检查进程是否正在运行。但是通过使用探针，您可以利用 Kubernetes 中的这种默认行为来添加自己的逻辑。</p>
<p><img src="https://images.contentstack.io/v3/assets/blt300387d93dabf50e/blt6000508012c0e26f/5b846323acedd45c0bf7c540/download" alt=""></p>
<h2 id="4-Service"><a href="#4-Service" class="headerlink" title="4. Service"></a>4. Service</h2><h3 id="不要使用-LoadBalancer-类型"><a href="#不要使用-LoadBalancer-类型" class="headerlink" title="不要使用 LoadBalancer 类型"></a>不要使用 LoadBalancer 类型</h3><p>每次你在部署文件里面加一个公有云提供商的 loadbalancer（负载均衡器）的时候，它都会创建一个。 它确实是高可用，速度快，但它需要花钱。</p>
<p>提示：使用 Ingress 代替，可让您通过单个端点对多个服务进行负载均衡。这不仅更简单，而且更便宜。</p>
<p>当然，这种策略只有在您使用 http 或 Web 内容时才有效，并且不适用于基于UDP或TCP的应用程序。</p>
<h3 id="Nodeport-类型足够好"><a href="#Nodeport-类型足够好" class="headerlink" title="Nodeport 类型足够好"></a>Nodeport 类型足够好</h3><p>这更多是个人偏好，并非所有人都推荐这一点。NodePort把你的应用通过一个VM的特定端口暴露到外网上。 问题就是它没有像负载均衡器那样有高可用。比如极端情况，VM挂了你的服务也挂了。</p>
<h3 id="将外部服务映射到内部服务"><a href="#将外部服务映射到内部服务" class="headerlink" title="将外部服务映射到内部服务"></a>将外部服务映射到内部服务</h3><p>这是大多数人不知道你可以在Kubernetes做的事情。如果您需要群集外部的服务，您可以使用类型为ExternalName的服务。现在您可以通过名称调用服务，Kubernetes管理器将您传递给它，就好像它是集群的一部分一样。如果服务位于同一网络上，Kubernetes会将服务视为服务，但它实际上位于服务之外。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: my-service</span><br><span class="line">  namespace: prod</span><br><span class="line">spec:</span><br><span class="line">  type: ExternalName</span><br><span class="line">  externalName: my.database.example.com</span><br></pre></td></tr></table></figure>
<p>查找主机时 <code>my-service.prod.svc.CLUSTER</code>，群集 DNS 服务将返回 <code>CNAME</code> 包含该值的记录 <code>my.database.example.com</code>。访问 my-service工作的方式与其他服务相同，但重要的区别在于重定向发生在 DNS 级别，而不是通过代理或转发。如果您以后决定将数据库移动到群集中，则可以启动其 pod，添加适当的选择器或端点，以及更改服务 type。</p>
<h2 id="5-应用程序架构"><a href="#5-应用程序架构" class="headerlink" title="5. 应用程序架构"></a>5. 应用程序架构</h2><h3 id="使用-helm-charts"><a href="#使用-helm-charts" class="headerlink" title="使用 helm charts"></a>使用 helm charts</h3><p>Helm 基本上是打包 Kubernetes 配置的存储库。如果要部署 MongoDB 。它有一个预配置的 Helm 图表，其中包含所有依赖项，您可以轻松地将其部署到集群中。</p>
<h3 id="所有下游依赖项都不可靠"><a href="#所有下游依赖项都不可靠" class="headerlink" title="所有下游依赖项都不可靠"></a>所有下游依赖项都不可靠</h3><p>您的应用程序中应包含逻辑和错误消息，以说明您无法控制的任何依赖项。Sandeep建议，为了帮助您进行下游管理，您可以使用像 Istio 或 Linkerd 这样的服务网格。</p>
<h3 id="确保您的微服务不是太微"><a href="#确保您的微服务不是太微" class="headerlink" title="确保您的微服务不是太微"></a>确保您的微服务不是太微</h3><p>您需要逻辑组件，而不是每个功能都变成微服务。</p>
<h3 id="使用命名空间来拆分群集"><a href="#使用命名空间来拆分群集" class="headerlink" title="使用命名空间来拆分群集"></a>使用命名空间来拆分群集</h3><p>例如，您可以在具有不同命名空间的同一群集中创建 Prod，Dev 和 Test，还可以使用命名空间来限制资源量，以便一个错误进程不会使用所有群集资源。</p>
<h3 id="基于角色的访问控制"><a href="#基于角色的访问控制" class="headerlink" title="基于角色的访问控制"></a>基于角色的访问控制</h3><p>作为最佳实践安全措施，制定适当的访问控制以限制对群集的访问量。</p>
<p>原文来自： <a href="https://www.weave.works/blog/kubernetes-best-practices" target="_blank" rel="noopener">https://www.weave.works/blog/kubernetes-best-practices</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">kuops</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://kuops.com/2018/09/12/Kubernetes-最佳实践/">https://kuops.com/2018/09/12/Kubernetes-最佳实践/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://kuops.com" target="_blank">Kuops Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/09/18/Kubernetes-资源对象之Service/"><i class="fa fa-chevron-left">  </i><span>Kubernetes资源对象之 Service</span></a></div><div class="next-post pull-right"><a href="/2018/08/04/Kubernetes-资源对象之HorizontalPodAutoscaler/"><span>Kubernetes 资源对象之 HorizontalPodAutoscaler</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://kuops.com/2018/09/12/Kubernetes-最佳实践/';
  this.page.identifier = '2018/09/12/Kubernetes-最佳实践/';
  this.page.title = 'Kubernetes 的最佳实践';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'kuops-com' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By kuops</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.4"></script><script src="/js/fancybox.js?version=1.5.4"></script><script src="/js/sidebar.js?version=1.5.4"></script><script src="/js/copy.js?version=1.5.4"></script><script src="/js/fireworks.js?version=1.5.4"></script><script src="/js/transition.js?version=1.5.4"></script><script src="/js/scroll.js?version=1.5.4"></script><script src="/js/head.js?version=1.5.4"></script></body></html>