<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Kubernets Pod 使用示例"><meta name="keywords" content=""><meta name="author" content="kuops,undefined"><meta name="copyright" content="kuops"><title>Kubernets Pod 使用示例 | Kuops Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.4"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: undefined
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernets-Pod-的使用"><span class="toc-number">1.</span> <span class="toc-text">Kubernets Pod 的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态-Pod"><span class="toc-number">2.</span> <span class="toc-text">静态 Pod</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-使用-conf-方式"><span class="toc-number">2.1.</span> <span class="toc-text">1. 使用 conf 方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-使用-HTTP"><span class="toc-number">2.2.</span> <span class="toc-text">2. 使用 HTTP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pod-运行多个容器"><span class="toc-number">3.</span> <span class="toc-text">Pod 运行多个容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pod-中容器共享-volume"><span class="toc-number">4.</span> <span class="toc-text">Pod 中容器共享 volume</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pod-资源限制"><span class="toc-number">5.</span> <span class="toc-text">Pod 资源限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init-容器"><span class="toc-number">6.</span> <span class="toc-text">init 容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使-pod-在指定节点运行"><span class="toc-number">7.</span> <span class="toc-text">使 pod 在指定节点运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从私有仓库拉取镜像"><span class="toc-number">8.</span> <span class="toc-text">从私有仓库拉取镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#健康检查"><span class="toc-number">9.</span> <span class="toc-text">健康检查</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#exec-方法"><span class="toc-number">9.1.</span> <span class="toc-text">exec 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-方法"><span class="toc-number">9.2.</span> <span class="toc-text">http 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-方法"><span class="toc-number">9.3.</span> <span class="toc-text">tcp 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pod-和-容器的上下文"><span class="toc-number">10.</span> <span class="toc-text">pod 和 容器的上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pod-的安全上下文"><span class="toc-number">10.1.</span> <span class="toc-text">pod 的安全上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器的安全上下文"><span class="toc-number">10.2.</span> <span class="toc-text">容器的安全上下文</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">kuops</div><div class="author-info__description text-center">巧者劳而智者忧，无能者无所求</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">36</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">5</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1529517901642&amp;di=5f7db410ab487b78dd0afc85bc246702&amp;imgtype=0&amp;src=http%3A%2F%2Fimg5.duitang.com%2Fuploads%2Fitem%2F201610%2F21%2F20161021234613_KvFXP.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Kuops Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Kubernets Pod 使用示例</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-06-20</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/kubernetes/">kubernetes</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><h2 id="Kubernets-Pod-的使用"><a href="#Kubernets-Pod-的使用" class="headerlink" title="Kubernets Pod 的使用"></a>Kubernets Pod 的使用</h2><p>通过 <a href="https://kuops.com/2018/06/11/Kubernetes-%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1%E4%B9%8BPod/">Kubernets 资源对象之 pod</a> 已经了解到 Pod 是什么，现在我们通过运行 Pod 了解一下  Pod 的具体用法。</p>
<h2 id="静态-Pod"><a href="#静态-Pod" class="headerlink" title="静态 Pod"></a>静态 Pod</h2><p>静态 <code>pod</code> 直接运行节点上的 <code>kubelet</code> 进程来管理，不经过 master 节点上的 API 服务器。当 <code>pod</code> 崩溃时会自动重启该 <code>pod</code>。静态 <code>pod</code> 没有健康检查。静态 <code>pod</code> 始终运行在同一个节点上。</p>
<p><code>Kubelet</code> 自动为每一个静态 <code>pod</code> 在 Kubernetes 的 API 服务器上创建一个镜像 Pod（Mirror Pod），因此可以在 API 服务器查询到该 pod，但是不被 API 服务器控制（例如不能删除）。</p>
<p>静态 <code>pod</code> 有两种创建方式：用配置文件或者通过 HTTP：</p>
<h3 id="1-使用-conf-方式"><a href="#1-使用-conf-方式" class="headerlink" title="1. 使用 conf 方式"></a>1. 使用 conf 方式</h3><p>kubelet 启动时增加 <code>--pod-manifest-path=/etc/kubelet.d/</code> 参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/kubernetes/manifests</span><br></pre></td></tr></table></figure></p>
<p>定义配置文件并启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF&gt; /etc/kubernetes/manifests/static-web.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: static-web</span><br><span class="line">  labels:</span><br><span class="line">    role: myrole</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: web</span><br><span class="line">      image: nginx</span><br><span class="line">      ports:</span><br><span class="line">        - name: web</span><br><span class="line">          containerPort: 80</span><br><span class="line">          protocol: TCP</span><br><span class="line">EOF</span><br><span class="line">#已经运行</span><br><span class="line">[root@kubernetes ~]# kubectl   get pod</span><br><span class="line">NAME                    READY     STATUS    RESTARTS   AGE</span><br><span class="line">static-web-kubernetes   1/1       Running   0          2m</span><br></pre></td></tr></table></figure></p>
<p>如果删除该文件，则对应 Pod 也会自动删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rm -f /etc/kubernetes/manifests/static-web.yaml</span><br><span class="line">#已经删除</span><br><span class="line">[root@kubernetes ~]# kubectl   get pod</span><br><span class="line">No resources found.</span><br></pre></td></tr></table></figure></p>
<h3 id="2-使用-HTTP"><a href="#2-使用-HTTP" class="headerlink" title="2. 使用 HTTP"></a>2. 使用 HTTP</h3><p>Kubelet 周期地从 <code>--manifest-url=</code> 参数指定的地址下载文件，并且把它翻译成 <code>JSON/YAML</code> 格式的 <code>pod</code> 定义。此后的操作方式与 <code>--pod-manifest-path=</code> 相同，kubelet 会不时地重新下载该文件，当文件变化时对应地终止或启动静态pod。</p>
<h2 id="Pod-运行多个容器"><a href="#Pod-运行多个容器" class="headerlink" title="Pod 运行多个容器"></a>Pod 运行多个容器</h2><p>两个镜像的 Dockerfile 都在我的仓库中 <a href="https://github.com/kuops/Dockerfiles.git" target="_blank" rel="noopener">https://github.com/kuops/Dockerfiles.git</a></p>
<p>创建 pod<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; nginx-flask-pod.yaml &lt;&lt;EOF</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-flask</span><br><span class="line">  labels:</span><br><span class="line">    name: nginx-flask</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: kuops/mynginx</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">      hostPort:  80</span><br><span class="line">  - name: flask</span><br><span class="line">    image: kuops/myflask</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 5000</span><br><span class="line">EOF</span><br><span class="line">kubectl create -f nginx-flask-pod.yaml</span><br></pre></td></tr></table></figure></p>
<p>由于使用 hostport 模式访问，通过参数 <code>-o wide</code>,找到 pod 所在节点，之后进行访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@kubernetes ~]# kubectl  get pod -o wide</span><br><span class="line">NAME          READY     STATUS    RESTARTS   AGE       IP           NODE</span><br><span class="line">nginx-flask   2/2       Running   0          2m        10.244.1.8   node1</span><br><span class="line"></span><br><span class="line">[root@kubernetes ~]# curl  node1</span><br><span class="line">Hello Flask!</span><br></pre></td></tr></table></figure></p>
<p>查看 nginx 容器使用的是 <code>localhost:5000</code> 访问的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@kubernetes ~]# kubectl exec -it nginx-flask --container nginx cat /etc/nginx/conf.d/default.conf</span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">    location / &#123;</span><br><span class="line">    proxy_pass      http://localhost:5000/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Pod-中容器共享-volume"><a href="#Pod-中容器共享-volume" class="headerlink" title="Pod 中容器共享 volume"></a>Pod 中容器共享 volume</h2><p>使用类型为 <code>empyDir</code> 的方式，挂载日志到日志搜集容器，设置的 Volume 名为 <code>app-logs</code> ,类型为 <code>empyDir</code>,挂载到 tomcat 的 <code>/usr/local/tomcat/logs</code> 目录，同时挂载到 logreader 容器内的 <code>/logs</code> 目录。 tomcat 容器启动后会向 <code>/usr/local/tomcat/logs</code> 写文件， logreader 就可以读取其中的文件了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; pod-volume-applogs.yaml &lt;&lt;EOF</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: volume-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: tomcat</span><br><span class="line">    image: tomcat</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 8080</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: app-logs</span><br><span class="line">      mountPath: /usr/local/tomcat/logs</span><br><span class="line">  - name: alpine</span><br><span class="line">    image: alpine</span><br><span class="line">    command: [&quot;sh&quot;, &quot;-c&quot;, &quot;tail -f /logs/catalina*.log&quot;]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: app-logs</span><br><span class="line">      mountPath: /logs</span><br><span class="line">  volumes:</span><br><span class="line">  - name: app-logs</span><br><span class="line">    emptyDir: &#123;&#125;</span><br><span class="line">EOF</span><br><span class="line">kubectl  create  -f pod-volume-applogs.yaml</span><br></pre></td></tr></table></figure>
<p>查看  logreader 输出的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs volume-pod -c alpine</span><br></pre></td></tr></table></figure></p>
<p>查看 tomcat 中文件的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl  exec  -it volume-pod -c tomcat ls /usr/local/tomcat/logs</span><br><span class="line">kubectl  exec  -it volume-pod -c tomcat -- tail -f /usr/local/tomcat/logs/catalina.2018-06-19.log</span><br></pre></td></tr></table></figure></p>
<h2 id="Pod-资源限制"><a href="#Pod-资源限制" class="headerlink" title="Pod 资源限制"></a>Pod 资源限制</h2><p>创建一个内存最小请求为 100M 最大为 200 M 的容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF&gt; memory-request-limit.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: memory-demo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: memory-demo-ctr</span><br><span class="line">    image: polinux/stress</span><br><span class="line">    resources:</span><br><span class="line">      limits:</span><br><span class="line">        memory: &quot;200Mi&quot;</span><br><span class="line">      requests:</span><br><span class="line">        memory: &quot;100Mi&quot;</span><br><span class="line">    command: [&quot;stress&quot;]</span><br><span class="line">    args: [&quot;--vm&quot;, &quot;1&quot;, &quot;--vm-bytes&quot;, &quot;150M&quot;, &quot;--vm-hang&quot;, &quot;1&quot;]</span><br><span class="line">EOF</span><br><span class="line">kubectl  create  -f memory-request-limit.yaml</span><br></pre></td></tr></table></figure></p>
<p>在配置文件中，该 <code>args</code> 部分在 <code>Container</code> 启动时提供参数。该 <code>--vm-bytes</code> , <code>150M</code> 参数告诉容器尝试分配的内存 150 MIB。</p>
<p>通过安装 <code>heapster</code> 查看资源使用情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@kubernetes ~]# kubectl  top pod</span><br><span class="line">NAME          CPU(cores)   MEMORY(bytes)</span><br><span class="line">memory-demo   14m          150Mi</span><br></pre></td></tr></table></figure>
<p>测试一下超过内存占用会怎么样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF&gt; memory-request-limit2.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: memory-demo-2</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: memory-demo-2-ctr</span><br><span class="line">    image: polinux/stress</span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        memory: &quot;50Mi&quot;</span><br><span class="line">      limits:</span><br><span class="line">        memory: &quot;100Mi&quot;</span><br><span class="line">    command: [&quot;stress&quot;]</span><br><span class="line">    args: [&quot;--vm&quot;, &quot;1&quot;, &quot;--vm-bytes&quot;, &quot;250M&quot;, &quot;--vm-hang&quot;, &quot;1&quot;]</span><br><span class="line">EOF</span><br><span class="line">kubectl  create  -f memory-request-limit2.yaml</span><br></pre></td></tr></table></figure></p>
<p>看到 <code>OOMKilled</code> ,输出显示容器因内存不足而终止（OOM）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@kubernetes ~]# kubectl  get pod</span><br><span class="line">NAME            READY     STATUS      RESTARTS   AGE</span><br><span class="line">memory-demo     1/1       Running     0          5m</span><br><span class="line">memory-demo-2   0/1       OOMKilled   1          6s</span><br></pre></td></tr></table></figure></p>
<p>如果请求一个超过宿主机内存的 pod，则永远处于 pending 状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF&gt; memory-request-limit3.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: memory-demo-3</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: memory-demo-3-ctr</span><br><span class="line">    image: polinux/stress</span><br><span class="line">    resources:</span><br><span class="line">      limits:</span><br><span class="line">        memory: &quot;1000Gi&quot;</span><br><span class="line">      requests:</span><br><span class="line">        memory: &quot;1000Gi&quot;</span><br><span class="line">    command: [&quot;stress&quot;]</span><br><span class="line">    args: [&quot;--vm&quot;, &quot;1&quot;, &quot;--vm-bytes&quot;, &quot;150M&quot;, &quot;--vm-hang&quot;, &quot;1&quot;]</span><br><span class="line">EOF</span><br><span class="line">kubectl  create  -f memory-request-limit3.yaml</span><br></pre></td></tr></table></figure></p>
<p>查看 Pod 状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@kubernetes ~]# kubectl  get pod</span><br><span class="line">NAME            READY     STATUS    RESTARTS   AGE</span><br><span class="line">memory-demo-3   0/1       Pending   0          3s</span><br></pre></td></tr></table></figure></p>
<p>查看有关Pod的详细信息，包括事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod memory-demo-3 --namespace=mem-example</span><br></pre></td></tr></table></figure></p>
<p>输出显示由于节点上的内存不足，无法调度Container：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Events:</span><br><span class="line">  ...  Reason            Message</span><br><span class="line">       ------            -------</span><br><span class="line">  ...  FailedScheduling  No nodes are available that match all of the following predicates:: Insufficient memory (3).</span><br></pre></td></tr></table></figure></p>
<p>内存资源以字节为单位进行测量。您可以将内存表达为普通整数或具有以下后缀之一的定点整数：E，P，T，G，M，K，Ei，Pi，Ti，Gi，Mi，Ki。例如，以下代表大致相同的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">128974848, 129e6, 129M , 123Mi</span><br></pre></td></tr></table></figure></p>
<p>创建一个限制 CPU 资源的请求, <code>-cpus &quot;2&quot;</code>参数告诉 Container 尝试使用 <code>2 cpus</code>。<code>0.5</code> 同样可以用 <code>500m</code> 表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;&apos;EOF&apos;&gt; cpu-request-limit.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: cpu-demo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: cpu-demo-ctr</span><br><span class="line">    image: vish/stress</span><br><span class="line">    resources:</span><br><span class="line">      limits:</span><br><span class="line">        cpu: &quot;1&quot;</span><br><span class="line">      requests:</span><br><span class="line">        cpu: &quot;0.5&quot;</span><br><span class="line">    args:</span><br><span class="line">    - -cpus</span><br><span class="line">    - &quot;2&quot;</span><br><span class="line">EOF</span><br><span class="line">kubectl create  -f cpu-request-limit.yaml</span><br></pre></td></tr></table></figure></p>
<h2 id="init-容器"><a href="#init-容器" class="headerlink" title="init 容器"></a>init 容器</h2><p>Init 容器先于其他容器运行，必须等 init 容器运行完成，再启动其他容器，如果 Pod 的 Init 容器失败，Kubernetes 会不断地重启该 Pod，直到 Init 容器成功为止。然而，如果 Pod 对应的 <code>restartPolicy</code> 为 <code>Never</code>，它不会重新启动。Init 容器支持应用容器的全部字段和特性，包括资源限制、数据卷和安全设置。 然而，Init 容器对资源请求和限制的处理稍有不同， Init 容器不支持 Readiness Probe，因为它们必须在 Pod 就绪之前运行完成。</p>
<p>如果为一个 Pod 指定了多个 Init 容器，那些容器会按顺序一次运行一个。 每个 Init 容器必须运行成功，下一个才能够运行。 当所有的 Init 容器运行完成时，Kubernetes 初始化 Pod 并像平常一样运行应用容器。</p>
<p>由于 Init Containers 具有独立于应用程序容器的图像，启动相关代码具有如下优势：</p>
<ul>
<li><p>出于安全原因，它们可以包含并运行不希望包含在应用程序 Container 映像中的实用程序。</p>
</li>
<li><p>它们可以包含使用工具和定制化代码来安装，但是不能出现在应用镜像中。例如，代码中需要使用类似 <code>sed</code>、 <code>awk</code>、 <code>python</code> 或 <code>dig</code>这样的工具，没必要 From 另一个镜像。</p>
</li>
<li><p>应用程序镜像的构建和部署角色可以独立工作，无需共同构建单个应用程序映像。</p>
</li>
<li><p>他们使用 Linux 命名空间，以便它们具有来自应用容器的不同文件系统视图。因此，他们可以获得应用程序容器无法访问的 secret 。</p>
</li>
<li><p>它们在应用程序容器启动之前运行完毕，并没有与应用容器并行运行，所以 Init 容器提供了一种简单的方式来阻塞或延迟应用容器的启动，直到满足了一组先决条件。</p>
</li>
</ul>
<p>以下是关于如何使用Init Containers的一些想法：</p>
<ul>
<li><p>等待一个 Service 完成创建，通过类似如下 shell 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;1..100&#125;; do sleep 1; if dig myservice; then exit 0; fi; exit 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册这个 Pod 到远程服务器，通过在命令中调用 API，类似如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://$MANAGEMENT_SERVICE_HOST:$MANAGEMENT_SERVICE_PORT/register -d &apos;instance=$(&lt;POD_NAME&gt;)&amp;ip=$(&lt;POD_IP&gt;)&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在启动应用容器之前等一段时间，使用类似 sleep 60 的命令。</p>
</li>
<li><p>克隆 Git 仓库到数据卷。</p>
</li>
<li><p>将配置值放到配置文件中，运行模板工具为主应用容器动态地生成配置文件。例如，在配置文件中存放 POD_IP 值，并使用 Jinja 生成主应用配置文件。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF&gt; init-containers.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: init-demo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: workdir</span><br><span class="line">      mountPath: /usr/share/nginx/html</span><br><span class="line">  # These containers are run during pod initialization</span><br><span class="line">  initContainers:</span><br><span class="line">  - name: install</span><br><span class="line">    image: busybox</span><br><span class="line">    command:</span><br><span class="line">    - wget</span><br><span class="line">    - &quot;-O&quot;</span><br><span class="line">    - &quot;/work-dir/index.html&quot;</span><br><span class="line">    - http://kubernetes.io</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: workdir</span><br><span class="line">      mountPath: &quot;/work-dir&quot;</span><br><span class="line">  dnsPolicy: Default</span><br><span class="line">  volumes:</span><br><span class="line">  - name: workdir</span><br><span class="line">    emptyDir: &#123;&#125;</span><br><span class="line">EOF</span><br><span class="line">kubectl create -f init-containers.yaml</span><br></pre></td></tr></table></figure>
<p>如果使用 <code>kubectl get pod init-demo</code> 看到已经运行，则可进入容器中，执行如下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install curl -y</span><br><span class="line">curl -s localhost|grep &apos;&lt;p&gt;Kubernetes is&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="使-pod-在指定节点运行"><a href="#使-pod-在指定节点运行" class="headerlink" title="使 pod 在指定节点运行"></a>使 pod 在指定节点运行</h2><p>将 Kubernetes Pod 分配给 Kubernetes 集群中的特定节点。</p>
<p>查询节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@kubernetes ~]# kubectl get node</span><br><span class="line">NAME         STATUS    ROLES     AGE       VERSION</span><br><span class="line">kubernetes   Ready     master    18h       v1.10.4</span><br><span class="line">node1        Ready     &lt;none&gt;    18h       v1.10.4</span><br></pre></td></tr></table></figure></p>
<p>选择一个节点，并添加一个标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label nodes kubernetes disktype=ssd</span><br></pre></td></tr></table></figure></p>
<p>可以查看 node 节点的标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@kubernetes ~]# kubectl get node --show-labels</span><br><span class="line">NAME         STATUS    ROLES     AGE       VERSION   LABELS</span><br><span class="line">kubernetes   Ready     master    23h       v1.10.4   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,disktype=ssd,kubernetes.io/hostname=kubernetes,node-role.kubernetes.io/master=</span><br><span class="line">node1        Ready     &lt;none&gt;    23h       v1.10.4   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/hostname=node1</span><br></pre></td></tr></table></figure></p>
<p>创建 Pod<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF&gt; pod.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  labels:</span><br><span class="line">    env: test</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">  nodeSelector:</span><br><span class="line">    disktype: ssd</span><br><span class="line">EOF</span><br><span class="line">kubectl create -f pod.yaml</span><br></pre></td></tr></table></figure></p>
<p>查看 pod  所在节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@kubernetes ~]# kubectl  get pod -o wide</span><br><span class="line">NAME        READY     STATUS    RESTARTS   AGE       IP            NODE</span><br><span class="line">init-demo   1/1       Running   0          16m       10.244.1.41   node1</span><br><span class="line">nginx       1/1       Running   0          10s       10.244.0.10   kubernetes</span><br></pre></td></tr></table></figure></p>
<h2 id="从私有仓库拉取镜像"><a href="#从私有仓库拉取镜像" class="headerlink" title="从私有仓库拉取镜像"></a>从私有仓库拉取镜像</h2><p>首先登陆 docker 仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure></p>
<p>登陆之后会生成 config.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@kubernetes ~]# cat ~/.docker/config.json</span><br><span class="line">&#123;</span><br><span class="line">        &quot;auths&quot;: &#123;</span><br><span class="line">                &quot;https://index.docker.io/v1/&quot;: &#123;</span><br><span class="line">                        &quot;auth&quot;: &quot;x.x.x.x&quot;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;HttpHeaders&quot;: &#123;</span><br><span class="line">                &quot;User-Agent&quot;: &quot;Docker-Client/18.03.1-ce (linux)&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建一个 secret,名为 <code>regcred</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret docker-registry regcred --docker-server=&lt;your-registry-server&gt; --docker-username=&lt;your-name&gt; --docker-password=&lt;your-pword&gt; --docker-email=&lt;your-email&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;your-registry-server&gt;</code> 是您的私有Docker注册表FQDN，上面 auth 字段的网址</li>
<li><code>&lt;your-name&gt;</code> 是您的 Docker 用户名。</li>
<li><code>&lt;your-pword&gt;</code> 是您的 Docker 密码。</li>
<li><code>&lt;your-email&gt;</code> 是您的 Docker 电子邮件。</li>
</ul>
<p>查看生成的 secret<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get secret regcred --output=yaml</span><br></pre></td></tr></table></figure></p>
<p>拉取镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF&gt; private-reg-pod.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: private-reg</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: private-reg-container</span><br><span class="line">    image: kuops/secret-demo</span><br><span class="line">  imagePullSecrets:</span><br><span class="line">  - name: regcred</span><br><span class="line">EOF</span><br><span class="line">kubectl create -f private-reg-pod.yaml</span><br></pre></td></tr></table></figure></p>
<h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><p>kubelet 使用 liveness probe（存活探针）来确定何时重启容器。例如，当应用程序处于运行状态但无法做进一步操作，liveness 探针将捕获到 deadlock，在这种状态下重新启动容器可以帮助尽可能使应用程序更易于使用。</p>
<p>Kubelet 使用 readiness probe（就绪探针）来确定容器是否已经就绪可以接受流量。只有当 Pod 中的容器都处于就绪状态时 kubelet 才会认定该 Pod处于就绪状态。该信号的作用是控制哪些 Pod应该作为service的后端。如果 Pod 处于非就绪状态，那么它们将会被从 service 的 load balancer 中移除。</p>
<h3 id="exec-方法"><a href="#exec-方法" class="headerlink" title="exec 方法"></a>exec 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF&gt; exec-liveness.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    test: liveness</span><br><span class="line">  name: liveness-exec</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: liveness</span><br><span class="line">    image: busybox</span><br><span class="line">    args:</span><br><span class="line">    - /bin/sh</span><br><span class="line">    - -c</span><br><span class="line">    - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600</span><br><span class="line">    livenessProbe:</span><br><span class="line">      exec:</span><br><span class="line">        command:</span><br><span class="line">        - cat</span><br><span class="line">        - /tmp/healthy</span><br><span class="line">      initialDelaySeconds: 5</span><br><span class="line">      periodSeconds: 5</span><br><span class="line">EOF</span><br><span class="line">kubectl create -f exec-liveness.yaml</span><br></pre></td></tr></table></figure>
<p>在配置文件中，您可以看到 <code>Pod</code> 有一个 <code>Container</code>。该 <code>periodSeconds</code> 字段指定该 <code>kubelet</code> 应每5秒执行一次活性探测。该 <code>initialDelaySeconds</code> 字段告诉 <code>kubelet</code> 在执行第一次探测之前应等待 5 秒钟。</p>
<p>要执行探测，kubelet 将在容器中执行 <code>cat /tmp/healthy</code> 命令。如果命令成功，返回值为 0，则 kubelet 认为容器是健康的。如果该命令返回一个非零值，则 kubelet 杀死容器并重新启动它。</p>
<p>当容器启动时，它执行这个命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh -c &quot;touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600&quot;</span><br></pre></td></tr></table></figure></p>
<p>在Container的生命的前30秒内，有一个 <code>/tmp/healthy</code> 文件。因此，在前 30 秒内，该命令 <code>cat /tmp/healthy</code> 返回一个成功代码。30 秒后，<code>cat /tmp/healthy</code> 返回失败代码。</p>
<p>使用 kubectl describe 可以看到容器杀死并重建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod liveness-exec</span><br></pre></td></tr></table></figure></p>
<p>输入如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Events:</span><br><span class="line">  Type     Reason                 Age               From               Message</span><br><span class="line">  ----     ------                 ----              ----               -------</span><br><span class="line">  Normal   Scheduled              2m                default-scheduler  Successfully assigned liveness-exec to node1</span><br><span class="line">  Normal   SuccessfulMountVolume  2m                kubelet, node1     MountVolume.SetUp succeeded for volume &quot;default-token-j7gsz&quot;</span><br><span class="line">  Warning  Unhealthy              47s (x6 over 2m)  kubelet, node1     Liveness probe failed: cat: can&apos;t open &apos;/tmp/healthy&apos;: No such file or directory</span><br><span class="line">  Normal   Pulling                16s (x3 over 2m)  kubelet, node1     pulling image &quot;busybox&quot;</span><br><span class="line">  Normal   Killing                16s (x2 over 1m)  kubelet, node1     Killing container with id docker://liveness:Container failed liveness probe.. Container will be killed and recreated.</span><br><span class="line">  Normal   Pulled                 15s (x3 over 2m)  kubelet, node1     Successfully pulled image &quot;busybox&quot;</span><br><span class="line">  Normal   Created                15s (x3 over 2m)  kubelet, node1     Created container</span><br><span class="line">  Normal   Started                15s (x3 over 2m)  kubelet, node1     Started container</span><br></pre></td></tr></table></figure></p>
<h3 id="http-方法"><a href="#http-方法" class="headerlink" title="http 方法"></a>http 方法</h3><p><code>periodSeconds</code> 字段指定该 kubelet 应每 3 秒执行一次活性探测, <code>initialDelaySeconds</code> 字段告诉kubelet在执行第一次探测之前应等待3秒钟。<code>kubelet</code> 会向容器内的 8080 端口发送 http <code>GET</code> 请求，如果服务器 <code>/healthz</code> 路径的处理程序返回成功代码，则 <code>kubelet</code> 会认为Container处于活动状态且健康。如果处理程序返回失败代码，则 <code>kubelet</code> 杀死容器并重新启动它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF&gt; http-liveness.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    test: liveness</span><br><span class="line">  name: liveness-http</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: liveness</span><br><span class="line">    image: kubernetes/liveness</span><br><span class="line">    args:</span><br><span class="line">    - /server</span><br><span class="line">    livenessProbe:</span><br><span class="line">      httpGet:</span><br><span class="line">        path: /healthz</span><br><span class="line">        port: 8080</span><br><span class="line">        httpHeaders:</span><br><span class="line">        - name: X-Custom-Header</span><br><span class="line">          value: Awesome</span><br><span class="line">      initialDelaySeconds: 3</span><br><span class="line">      periodSeconds: 3</span><br><span class="line">EOF</span><br><span class="line">kubectl create -f http-liveness.yaml</span><br></pre></td></tr></table></figure>
<p>对于容器 <code>/healthz</code> 大于 10 秒,处理程序返回状态 500。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(&quot;/healthz&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    duration := time.Now().Sub(started)</span><br><span class="line">    if duration.Seconds() &gt; 10 &#123;</span><br><span class="line">        w.WriteHeader(500)</span><br><span class="line">        w.Write([]byte(fmt.Sprintf(&quot;error: %v&quot;, duration.Seconds())))</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        w.WriteHeader(200)</span><br><span class="line">        w.Write([]byte(&quot;ok&quot;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="tcp-方法"><a href="#tcp-方法" class="headerlink" title="tcp 方法"></a>tcp 方法</h3><p>TCP 检查的配置与 HTTP 检查非常相似。容器启动后5秒钟，kubelet将发送第一个准备就绪探针,如果探针成功，则将标记为已准备就绪。该 <code>kubelet</code> 将继续每10秒运行一次该检查,该配置还包括活动探测器。容器启动 15 秒后，<code>Kubelet</code> 将运行第一个活性探针。就像就绪探测器一样，它将尝试连接到 goproxy 端口8080上的 容器。如果活动探测失败，容器将重新启动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF&gt; tcp-liveness-readiness.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: goproxy</span><br><span class="line">  labels:</span><br><span class="line">    app: goproxy</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: goproxy</span><br><span class="line">    image: tomcat</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 8080</span><br><span class="line">    readinessProbe:</span><br><span class="line">      tcpSocket:</span><br><span class="line">        port: 8080</span><br><span class="line">      initialDelaySeconds: 5</span><br><span class="line">      periodSeconds: 10</span><br><span class="line">    livenessProbe:</span><br><span class="line">      tcpSocket:</span><br><span class="line">        port: 8080</span><br><span class="line">      initialDelaySeconds: 15</span><br><span class="line">      periodSeconds: 20</span><br><span class="line">EOF</span><br><span class="line">kubectl create -f tcp-liveness-readiness.yaml</span><br></pre></td></tr></table></figure>
<p>有时，应用程序暂时无法提供流量。例如，应用程序可能需要在启动过程中加载大型数据或配置文件。在这种情况下，你不想杀死应用程序，但你也不想发送请求。Kubernetes提供准备就绪探测器来检测和缓解这些情况。容器报告说他们没有准备好的吊舱不会通过Kubernetes服务收到流量。</p>
<p>准备探测器的配置与活性探测器类似。唯一的区别是你使用readinessProbe字段而不是livenessProbe字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">readinessProbe:</span><br><span class="line">  exec:</span><br><span class="line">    command:</span><br><span class="line">    - cat</span><br><span class="line">    - /tmp/healthy</span><br><span class="line">  initialDelaySeconds: 5</span><br><span class="line">  periodSeconds: 5</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>探针的其他字段，查看 <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/</a></p>
</blockquote>
<h2 id="pod-和-容器的上下文"><a href="#pod-和-容器的上下文" class="headerlink" title="pod 和 容器的上下文"></a>pod 和 容器的上下文</h2><h3 id="pod-的安全上下文"><a href="#pod-的安全上下文" class="headerlink" title="pod 的安全上下文"></a>pod 的安全上下文</h3><p>要指定 <code>Pod</code> 的安全设置，请 <code>securityContext</code> 在Pod规范中包含该字段。该 <code>securityContext</code> 字段是一个 <code>PodSecurityContext</code> 对象。您为 Pod 指定的安全设置适用于Pod中的所有容器。以下是具有卷securityContext和emptyDir卷的Pod的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF&gt; security-context.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: security-context-demo</span><br><span class="line">spec:</span><br><span class="line">  securityContext:</span><br><span class="line">    runAsUser: 1000</span><br><span class="line">    fsGroup: 2000</span><br><span class="line">  volumes:</span><br><span class="line">  - name: sec-ctx-vol</span><br><span class="line">    emptyDir: &#123;&#125;</span><br><span class="line">  containers:</span><br><span class="line">  - name: sec-ctx-demo</span><br><span class="line">    image: kuops/node-hello:1.0</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: sec-ctx-vol</span><br><span class="line">      mountPath: /data/demo</span><br><span class="line">    securityContext:</span><br><span class="line">      allowPrivilegeEscalation: false</span><br><span class="line">EOF</span><br><span class="line">kubectl create -f security-context.yaml</span><br></pre></td></tr></table></figure>
<p>获取运行Container的shell：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it security-context-demo -- sh</span><br></pre></td></tr></table></figure></p>
<p>在你的shell中，列出正在运行的进程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure></p>
<p>输出显示进程正在以用户 1000 身份运行，这是以下值 <code>runAsUser</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">USER   PID %CPU %MEM    VSZ   RSS TTY   STAT START   TIME COMMAND</span><br><span class="line">1000     1  0.0  0.0   4336   724 ?     Ss   18:16   0:00 /bin/sh -c node server.js</span><br><span class="line">1000     5  0.2  0.6 772124 22768 ?     Sl   18:16   0:00 node server.js</span><br></pre></td></tr></table></figure></p>
<p>在你的shell中，导航到/data并列出一个目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /data</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure></p>
<p>输出显示该/data/demo目录具有组ID 2000，该值是fsGroup。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxrwsrwx 2 root 2000 4096 Jun  6 20:08 demo</span><br></pre></td></tr></table></figure></p>
<p>在你的 shell中，进入 /data/demo 并创建一个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd demo</span><br><span class="line">echo hello &gt; testfile</span><br></pre></td></tr></table></figure></p>
<p>列出目录中的文件/data/demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure></p>
<p>输出显示testfile具有组ID 2000，它是的值fsGroup。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 1000 2000 6 Jun  6 20:08 testfile</span><br></pre></td></tr></table></figure></p>
<h3 id="容器的安全上下文"><a href="#容器的安全上下文" class="headerlink" title="容器的安全上下文"></a>容器的安全上下文</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF&gt; security-context-2.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: security-context-demo-2</span><br><span class="line">spec:</span><br><span class="line">  securityContext:</span><br><span class="line">    runAsUser: 1000</span><br><span class="line">  containers:</span><br><span class="line">  - name: sec-ctx-demo-2</span><br><span class="line">    image: kuops/node-hello:1.0</span><br><span class="line">    securityContext:</span><br><span class="line">      runAsUser: 2000</span><br><span class="line">      allowPrivilegeEscalation: false</span><br><span class="line">EOF</span><br><span class="line">kubectl create -f security-context-2.yaml</span><br></pre></td></tr></table></figure>
<p>同样 <code>ps aux</code> 查看到的运行用户是 2000<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">2000         1  0.0  0.0   4336   764 ?        Ss   20:36   0:00 /bin/sh -c node server.js</span><br><span class="line">2000         8  0.1  0.5 772124 22604 ?        Sl   20:36   0:00 node server.js</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">kuops</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://kuops.com/2018/06/20/Kubernetes-pod-使用示例/">https://kuops.com/2018/06/20/Kubernetes-pod-使用示例/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://kuops.com" target="_blank">Kuops Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/06/22/Kubernetes-资源对象之ConfigMap/"><i class="fa fa-chevron-left">  </i><span>Kubernetes资源对象之ConfigMap</span></a></div><div class="next-post pull-right"><a href="/2018/06/11/Kubernetes-资源对象之Pod/"><span>Kubernetes-资源对象之Pod</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://kuops.com/2018/06/20/Kubernetes-pod-使用示例/';
  this.page.identifier = '2018/06/20/Kubernetes-pod-使用示例/';
  this.page.title = 'Kubernets Pod 使用示例';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'kuops-com' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By kuops</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.4"></script><script src="/js/fancybox.js?version=1.5.4"></script><script src="/js/sidebar.js?version=1.5.4"></script><script src="/js/copy.js?version=1.5.4"></script><script src="/js/fireworks.js?version=1.5.4"></script><script src="/js/transition.js?version=1.5.4"></script><script src="/js/scroll.js?version=1.5.4"></script><script src="/js/head.js?version=1.5.4"></script></body></html>